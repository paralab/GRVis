One of the most fundamental things we learned from this project is how to properly configure and build VTK for parallel rendering using the Python wrapping. Throughout the project we ran into issues that we could trace back to how we initially configured the VTK build. For instance, on our local machines, we built VTK using OpenGL2 but once we transitioned to the kingspeak CHPC cluster we started running into errors. These errors were due to OpenGL2 not supporting software rendering on the CHPC machines. Unfortunately we could not utilize hardware rendering seemingly due to how things are set up on CHPC's side and we did not end up finding a workaround and had to stick with software rendering.

The next fundamental thing we learned from this project was how to properly launch a parallel rendering job using MPI and how the work is distributed amongst the nodes. In order to launch a job, we used the usual mpirun command with the launch configuration we desired. Then each process uses the pvtkpython program that was built with VTK to run our script. Then when running our code with an interactive window, we learned how pvtkpython separates the dataset. When running with many processes, each process will have a rendering window that shows which portion of the data it is handling. Then the root node's interactive window will have the final fully gathered scene. This was useful to see exactly how the data and work was being distributed.

Finally, the most significant thing we learned was how to replicate the filters and processing that we used in ParaView for the homeworks. We used the Python VTK examples provided in the VTK documentation to get us started, however, many small issues arose that weren't covered in the examples that we had to handle. For instance, the provided example for exporting a scene as a screenshot didn't include a line of code that resets the camera. Without this line of code, the renderer would not display anything and we kept getting blank output images. By digging into the documentation any time these little issues arose, we learned quite a bit about the underlying idiosyncracies of VTK which made it easier and easier to diagnose and fix the problems that we encountered.